---
layout: post
title: No.30 인라인 함수는 미주알고주알 따져서 이해해 두자.
date: 2019-01-06
categories: Effective_C++
tags: C++ Effective_C++
---

인라인 함수는 
- 함수처럼 보이고 함수처럼 동작
- 매크로보다 훨씬 안전하고 쓰기 좋음
- 함수 호출시 발생하는 오버헤드 걱정 필요 없음
- 컴파일러가 함수 본문에 대해 문맥별 최적화(Context-specific)에 용이
- 인라인 함수는 함수 호출문은 그 함수 본문으로 변경

컴파일러 최적화는 
- 함수 호출이 없는 코드가 연속적으로 이어지는 구간에 적용 되도록 설계
- 컴파일러는 아웃라인 함수 호출에 대해 이런 최적화를 적용하지 않음
> 아웃라인 함수 : 일반적인 함수 호출


인라인 함수 남발할 경우
- (단점) 메모리가 제한된 컴퓨터에서는 프로그램 크기가 그 기계에서 쓸수 있는 공간을 넘어 버릴수 있음
- (단점) 가상 메모리를 쓰는 환경에서는 
    - 인라인 함수로 부풀려진 코드는 성능의 걸림돌이 되기 쉽다.
    - 페이징 횟수가 늘어나고 명령어 캐시 적중률이 떨어짐
- (장점) 본문 길이가 굉장히 짧은 인라인 함수를 사용하면 함수 본문에 대해 만들어지는 코드의 크기가 함수 호출문에 대해 만들어진 코드보다 작아질수 있음
    - 이럴 경우 목적 코드의 크기도 작아지며 명령어 캐시 적중률도 높아짐
    - 함수 호출과 반환값 처리하는 것도 비용

인라인은 컴파일러에 '요청'을 하는것이지, 명령이 아님
- 이런 요청은 컴파일러가 그냥 하는 경우(암시적 선언)
- 사용자가 적접 컴파일러에게 요청(명시적 선언)으로 인한 것 

암시적 선언
```c++
class Person {
public:
    ...
    int age() const { return theAge; }  // 암시적 인라인 요청
                                        // age 는 클래스 정의 내부에 정의
    ...
private:
    int theAge;
};
```

명시적 선언
- 함수 정의 앞에 inline 키워드를 추가

```c++
template<typename T>
inline const T& std::max( const T& a, const T& b )
{ return a < b ? b : a; }
```

인라인 함수는 대체적으로 헤더파일에 위치하는 이유
- 대부분의 빌드 환경에서 인라인을 컴파일 도중에 수행
- 인라인 함수 호출은 그 함수의 본문으로 바꿔치기 하려면 일단 컴파일러가 어떤 형태인지 알고 있어야 함

인라인은 컴파일러 선에서 무시할수 있는 요청
- 컴파일러가 보기에 복잡한 함수는 절대 인라인 확장의 대상에 넣지 않음(루프나 재귀)
- 간단한 함수라도 가상 함수 호출같은 것은 절대 인리인 안됨
    - virtual 의 의미가 "어떤 함수를 호출하지 결정하는 작업을 실행중에 결정"
    - inline 의 의미가 "함수 호출 위치에 호출된 함수를 끼워 넣는 작업을 실행 전에 수행"

함수에 대한 인라인이 실패 했을 경우 경고 메시지를 출력

인라인 함수의 주소를 취하는 코드가 있으면 컴파일러는 이 코드를 위해 인라인 함수를 아웃라인 함수로 생성 
인라인 함수로 선언된 함수를 함수 포인터를 통해 호출하는 경우에 인라인화 되지 않음

```c++
inline void f() { ... } // 이 f()의 호출은 컴파일러가 반드시 인리인화를 수행

void (*pf)() = f;       // pf 는 f() 을 가리키는 함수 포인터
..
f();                    // 인라인화 

pf();                   // 인라인화 되지 않음
                        // 함수 포인터를 통하여 호출
```

생성자와 소멸자는 인라인하기에 좋지 않은 함수 

```c++
class Base {
public:
    ...
private:
    std::string bm1, bm2;
};

class Derived : public Base {
public:
    Derived() { };
    ...
private:
    std::string dm1, dm2, dm3;
};
```
c++ 은 '무엇을' 해야 하는지는 정해 두었지만 그것을 '어떻게' 해야 하는지는 정해 놓지 않음
'어떻게' 부분은 컴파일러 구현자에게 달려 있음 

실제 호출은 아래와 비슷
```c++
Derived::Derived()
{
    Base::Base();
    
    try { dm1.std::string::string();
    } catch ( ... ) {
        Base:~Base();
        throw;
    }
    
    try { dm2.std::string::string();
    } catch ( ... ) {
        dm1.std::string::~string();
        Base:~Base();
        throw;
    }
    
    try { dm3.std::string::string();
    } catch ( ... ) {
        dm2.std::string::~string();
        dm1.std::string::~string();
        Base:~Base();
        throw;
    }
}
```

라이브러리를 설계시 함수를 인라인으로 선언할 때 
- 그 영향에 대해 많은 고민을 해야함
- 사용자의 눈에 뻔히 보이는 인라인 함수에 대해서는 라이브러리 차원에서 바이너리 업그레이드를 제공할수 없음
- 라이브러리에서 인라인 함수를 사용할 경우 해당 인라인 함수가 수정 되면 라이브러리를 사용하는 코드도 다시 컴파일되어야 함

우선 아무것도 인라인하지 말아야 한다. 아니면 꼭 인라인해야 하는 함수 혹은 정말 단순한 함수에 한해서만 인라인 함수로 선언하는 것으로 시작해야 한다. 


> 
1. 함수 인라인은 작고, 자주 호출되는 함수에 대해서만 하는 것으로 묶어두자. 이렇게 하면 디버깅및 라이브러리의 바이너리 업그레이드가 용이해지고, 자칫 생길 수 있는 코드 부풀림 현상이 최소화 되며, 프로그램의 속력이 더 빨라 질 수 있는 여지가 최고로 많아진다.
2. 함수 템플릿이 대개 헤더 파일에 들어 간다는 일반적인 부분만 생각해서 이들을 인라인으로 선언하면 안된다.

